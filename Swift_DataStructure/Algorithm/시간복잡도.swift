//
//  시간복잡도.swift
//  Swift_DataStructure
//
//  Created by 이은재 on 2023/07/10.
//

import Foundation

/*
 시간 복잡도
 : 알고리즘의 실행 속도
 
 하나의 문제를 풀기 위한 여러 알고리즘이 존재할 수 있음
 최악의 상황에서도 실행 속도가 빠른 최적의 코드를 작성하는 것이 좋은 알고리즘이라고 할 수 있겠음
 따라서 좋은 알고리즘을 짜기 위해서는 시간 복잡도가 중요함
 
 시간 복잡도를 나타내는데 사용되는 성능 표기법 3가지
 1. 빅오 표기법 : 최악의 상황에서 실행 시간
 2. 오메가 표기법 : 최상의 상황에서 실행 시간
 3. 세타 표기법 : 평균 실행 시간
 
 주로 시간 복잡도는 빅오 표기법을 많이 사용함
 
 공간 복잡도
 : 알고리즘이 사용하는 메모리 크기
 
 공간 복잡도의 중요도는 시간 복잡도에 비해 낮음
 기술의 발전으로 메모리 크기가 늘어났기 때문
 
 빅오 표기법
 
 👍 O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) 👎
 O(1)에 가까울 수록 시간 복잡도가 낮은 것(실행 횟수가 적음), O(n!)에 가까울 수록 시간 복잡도가 높은 것(실행 횟수가 많음)
 */

// O(1)
// 입력 n에 상관 없이 Hello 라는 메세지를 한 번만 출력함
// n과 상관 없이 상수 1만큼 실행 되었다고 표현 -> O(1)
func sayHello(n: Int) {
    print("Hello!")
}
// O(1)
// 상수 3만큼 실행 된 것이니 O(3)으로 표현? -> X
// 상수가 몇 번 실행되었는지는 취급하지 않음 -> O(1)
func sayHello2(n: Int) {
    print("Hello!")
    print("Hello!")
    print("Hello!")
}

// O(n)
// 입력 n만큼 출력을 반복하고 있음
// 시간 복잡도에서 보통 중요한 것은 반복문
// 이 함수는 입력 n만큼 반복문을 실행 -> O(n)
func sayHello3(n: Int) {
    for _ in 0..<n {
        print("Hello!")
    }
}
// 이 경우엔 실행 횟수는 실제로 10n이 될 것임 그럼 O(10n)으로 표기할까?? -> X
// n앞에 붙은 10은 부수적인 별로 중요하지 않은 횟수 이기 때문에 O(n)으로 표기함
func sayHello4(n: Int) {
    for _ in 0..<10 {
        for _ in 0..<n {
            print("Hello!")
        }
    }
}

// O(n²)
// 반복문 2개가 모두 입력 n에 의해 실행되고 있음
// 반복문을 통해 n²개의 출력을 하고 있는 것임
func sayHello5(n: Int) {
    for _ in 0..<n {
        for _ in 0..<n {
            print("Hello!")
        }
    }
}
